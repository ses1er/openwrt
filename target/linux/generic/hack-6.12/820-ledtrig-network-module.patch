--- a/drivers/leds/trigger/Kconfig
+++ b/drivers/leds/trigger/Kconfig
@@ -129,6 +129,14 @@ config LEDS_TRIGGER_NETDEV
 	  This allows LEDs to be controlled by network device activity.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_NETWORK
+	tristate "LED trigger for network interfaces"
+	depends on NET
+	help
+	  This allows LEDs to be controlled by network interfaces, aggregated by
+	  family (lan/wan/wlan), with an optional per-LED "-online" mode.
+	  If unsure, say Y.
+
 config LEDS_TRIGGER_PATTERN
 	tristate "LED Pattern Trigger"
 	help
--- /dev/null
+++ b/drivers/leds/trigger/ledtrig-network.c
@@ -0,0 +1,622 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * LED trigger for network interfaces.
+ *
+ * - Aggregated per-family (lan/wan/wlan).
+ * - Each LED requests a family via DT "function" (lan, wan, wlan) or, if missing,
+ *   the function can be inferred from the LED name (e.g. "green:wlan").
+ *   An optional "-online" suffix is accepted (e.g. "wlan-online").
+ *
+ * Behaviour:
+ * - wlan (normal): throughput -> blink/solid
+ * - lan/wan (normal): oneshot blink on packet-count change.
+ * - wlan-online / lan-online / wan-online: steady ON when any tracked interface
+ *   of that family has carrier; otherwise OFF.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/leds.h>
+#include <linux/mutex.h>
+#include <linux/netdevice.h>
+#include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/list.h>
+#include <linux/atomic.h>
+#include <linux/compiler.h>
+#include <linux/string.h>
+#include "../leds.h"
+
+#define MAX_IFACES 16
+#define DEFAULT_INTERVAL_MS 50
+
+enum net_trig_type {
+	NET_TRIG_LAN = 0,
+	NET_TRIG_WAN,
+	NET_TRIG_WLAN,
+	NET_TRIG_TYPE_MAX,
+};
+
+static const char * const type_names[] = {
+	[NET_TRIG_LAN] = "lan",
+	[NET_TRIG_WAN] = "wan",
+	[NET_TRIG_WLAN] = "wlan",
+};
+
+/* wlan throughput table */
+static const struct {
+	u32 throughput;
+	unsigned long on_ms;
+	unsigned long off_ms;
+} wlan_tpt_table[] = {
+	{   64, 200, 800 },
+	{  512, 200, 300 },
+	{ 2048, 200, 150 },
+	{10000, 200,  50 },
+	{54000, 100,  50 },
+};
+
+struct net_mgr {
+	enum net_trig_type type; /* family: lan/wan/wlan */
+
+	struct mutex lock;
+	struct notifier_block notifier;
+	struct delayed_work work;
+
+	struct net_device *devs[MAX_IFACES];
+	int dev_count;
+
+	u64 agg_rx_packets;
+	u64 agg_tx_packets;
+	u64 agg_rx_bytes;
+	u64 agg_tx_bytes;
+
+	struct list_head leds;
+	atomic_t refcnt;
+};
+
+struct net_led {
+	struct list_head node;
+	struct led_classdev *led_cdev;
+	struct net_mgr *mgr;
+
+	u64 last_rx_packets;
+	u64 last_tx_packets;
+	u64 last_rx_bytes;
+	u64 last_tx_bytes;
+
+	bool online_only; /* true for "xxx-online" requested LED */
+};
+
+static DEFINE_MUTEX(managers_lock);
+static struct net_mgr *managers[NET_TRIG_TYPE_MAX];
+
+/* helpers */
+static inline void led_set_off_full(struct led_classdev *led, bool on)
+{
+	led_stop_software_blink(led);
+	led_set_brightness(led, on ? LED_FULL : LED_OFF);
+}
+
+static inline void led_set_oneshot_ms(struct led_classdev *led, unsigned long ms)
+{
+	led_stop_software_blink(led);
+	led_blink_set_oneshot(led, &ms, &ms, true);
+}
+
+/* helper: check that next char after prefix is digit, '-' or NUL */
+static inline bool next_char_ok(const char *s, size_t pos)
+{
+	char c = s[pos];
+	return c == '\0' || c == '-' || (c >= '0' && c <= '9');
+}
+
+/* name matching: lan/wan; wlan matched by various wifi prefixes with restriction
+ * additionally accept ath (Atheros) and ra/rai (Ralink/MediaTek) prefixes.
+ * For lan and wan require next char to be digit/'-' or end to avoid accidental matches.
+ */
+static bool name_matches_type(const char *name, enum net_trig_type type)
+{
+	if (!name)
+		return false;
+	switch (type) {
+
+	case NET_TRIG_LAN:
+		/* accept "lan", "lanX", "lan-X" */
+		if (!strncmp(name, "lan", 3))
+			return next_char_ok(name, 3);
+		return false;
+	case NET_TRIG_WAN:
+		/* accept "wan", "wanX", "wan-X" */
+		if (!strncmp(name, "wan", 3))
+			return next_char_ok(name, 3);
+		return false;
+	case NET_TRIG_WLAN:
+		/* accept "phyX", "wlX"/"wl-..." or "wlan" and common driver prefixes */
+		if (!strncmp(name, "phy", 3))
+			return next_char_ok(name, 3);
+		if (!strncmp(name, "wlan", 4))
+			return next_char_ok(name, 4);
+		if (!strncmp(name, "wl", 2))
+			return next_char_ok(name, 2);
+		/* Atheros (athX) */
+		if (!strncmp(name, "ath", 3))
+			return next_char_ok(name, 3);
+		/* Ralink/MediaTek: check "rai" (e.g. rai0) first, then "ra" (ra0) */
+		if (!strncmp(name, "rai", 3))
+			return next_char_ok(name, 3);
+		if (!strncmp(name, "ra", 2))
+			return next_char_ok(name, 2);
+		return false;
+	default:
+		return false;
+	}
+}
+
+/* Parse function string (from DT or inferred LED name).
+ * If fn ends with "-online", set *online_only = true and return base family.
+ * Returns -1 on unknown.
+ */
+static int parse_function_string(const char *fn, bool *online_only)
+{
+	size_t len;
+
+	if (!fn)
+		return -1;
+
+	*online_only = false;
+	len = strlen(fn);
+
+	if (len > 7 && !strcmp(fn + len - 7, "-online")) {
+		*online_only = true;
+		len -= 7;
+	}
+
+	if (len == 3 && !strncmp(fn, "lan", 3))
+		return NET_TRIG_LAN;
+	if (len == 3 && !strncmp(fn, "wan", 3))
+		return NET_TRIG_WAN;
+	if (len == 4 && !strncmp(fn, "wlan", 4))
+		return NET_TRIG_WLAN;
+
+	return -1;
+}
+
+/* safe stats read wrapper */
+static void get_dev_stats_safe(struct net_device *dev, struct rtnl_link_stats64 *st)
+{
+	memset(st, 0, sizeof(*st));
+	dev_get_stats(dev, st);
+}
+
+/* update single LED according to manager aggregation and its online_only flag */
+static void update_led(struct net_led *e, struct net_mgr *m, bool any_online)
+{
+	long unsigned int on_ms, off_ms;
+	struct led_classdev *led = e->led_cdev;
+
+	/* defensive: avoid deref if led unexpectedly NULL */
+	if (!led)
+		return;
+
+	/* If LED requested online-only, reflect any_online */
+	if (e->online_only) {
+		led_set_off_full(led, any_online);
+		return;
+	}
+
+	/* For non-online-only LEDs: if no tracked interface has carrier,
+	 * keep the LED off and reset history baseline to avoid spurious deltas
+	 * when carrier later returns.
+	 */
+	if (!any_online) {
+		led_set_off_full(led, false);
+
+		e->last_rx_packets = m->agg_rx_packets;
+		e->last_tx_packets = m->agg_tx_packets;
+		e->last_rx_bytes   = m->agg_rx_bytes;
+		e->last_tx_bytes   = m->agg_tx_bytes;
+
+		return;
+	}
+
+	/* non-online-only behaviour depends on family */
+	if (m->type == NET_TRIG_WLAN) {
+		/* throughput-driven */
+		u64 bytes_delta = (m->agg_rx_bytes - e->last_rx_bytes) +
+				  (m->agg_tx_bytes - e->last_tx_bytes);
+		u64 bits_per_sec = div64_u64(bytes_delta * 8ULL * 1000ULL, 2 * DEFAULT_INTERVAL_MS);
+		u64 kbps = div64_u64(bits_per_sec, 1000ULL);
+
+		if (kbps == 0)
+			led_set_off_full(led, true);
+		else {
+			int idx = 0, t;
+			for (t = 0; t < ARRAY_SIZE(wlan_tpt_table); t++) {
+				if (kbps >= wlan_tpt_table[t].throughput)
+					idx = t;
+				else
+					break;
+			}
+
+			on_ms = wlan_tpt_table[idx].on_ms;
+			off_ms = wlan_tpt_table[idx].off_ms;
+			led_blink_set(led, &on_ms, &off_ms);
+		}
+
+		e->last_rx_bytes = m->agg_rx_bytes;
+		e->last_tx_bytes = m->agg_tx_bytes;
+	} else {
+		/* LAN/WAN: oneshot on packet-count change */
+		u64 rx_sum = m->agg_rx_packets;
+		u64 tx_sum = m->agg_tx_packets;
+
+		if (rx_sum != e->last_rx_packets || tx_sum != e->last_tx_packets) {
+			unsigned long ms = DEFAULT_INTERVAL_MS;
+			led_set_oneshot_ms(led, ms);
+		} else {
+			led_set_off_full(led, true);
+		}
+		e->last_rx_packets = rx_sum;
+		e->last_tx_packets = tx_sum;
+	}
+}
+
+/* core work: aggregate + update LEDs */
+static void net_mgr_work(struct work_struct *work)
+{
+	struct net_mgr *m = container_of(work, struct net_mgr, work.work);
+	bool any_online = false;
+	int i;
+
+	mutex_lock(&m->lock);
+
+	if (m->dev_count == 0) {
+		struct net_led *e;
+		m->agg_rx_packets = m->agg_tx_packets = 0;
+		m->agg_rx_bytes = m->agg_tx_bytes = 0;
+		list_for_each_entry(e, &m->leds, node) {
+			led_set_off_full(e->led_cdev, false);
+			e->last_rx_packets = e->last_tx_packets = 0;
+			e->last_rx_bytes = e->last_tx_bytes = 0;
+		}
+		mutex_unlock(&m->lock);
+		schedule_delayed_work(&m->work, msecs_to_jiffies(2 * DEFAULT_INTERVAL_MS));
+		return;
+	}
+
+	/* aggregate */
+	m->agg_rx_packets = m->agg_tx_packets = 0;
+	m->agg_rx_bytes = m->agg_tx_bytes = 0;
+
+	/* detect any tracked-interface online (carrier) and sum stats */
+	for (i = 0; i < m->dev_count; i++) {
+		struct net_device *dev = m->devs[i];
+		struct rtnl_link_stats64 st;
+
+		if (!dev)
+			continue;
+
+		get_dev_stats_safe(dev, &st);
+		m->agg_rx_packets += st.rx_packets;
+		m->agg_tx_packets += st.tx_packets;
+		m->agg_rx_bytes += st.rx_bytes;
+		m->agg_tx_bytes += st.tx_bytes;
+
+		if (netif_running(dev) && netif_carrier_ok(dev))
+			any_online = true;
+	}
+
+	/* update each subscribed LED according to its online_only flag and family */
+	{
+		struct net_led *e;
+		list_for_each_entry(e, &m->leds, node)
+			update_led(e, m, any_online);
+	}
+
+	mutex_unlock(&m->lock);
+	schedule_delayed_work(&m->work, msecs_to_jiffies(2 * DEFAULT_INTERVAL_MS));
+}
+
+/* notifier: manage tracked devices */
+static int net_mgr_notify(struct notifier_block *nb, unsigned long event, void *ptr)
+{
+	struct netdev_notifier_info *info = ptr;
+	struct net_device *tmp, *dev = NULL;
+	struct net_mgr *m = container_of(nb, struct net_mgr, notifier);
+	int i, id = -1, newid;
+
+	if (event != NETDEV_REGISTER && event != NETDEV_UNREGISTER &&
+	    event != NETDEV_CHANGENAME)
+		return NOTIFY_DONE;
+
+	if (!info)
+		return NOTIFY_DONE;
+
+	dev = info->dev;
+
+	if (!dev)
+		return NOTIFY_DONE;
+
+	mutex_lock(&m->lock);
+	for (i = 0; i < m->dev_count; i++) {
+		if (m->devs[i] && m->devs[i] == dev) {
+			id = i;
+			break;
+		}
+	}
+
+	switch (event) {
+	case NETDEV_UNREGISTER:
+		if (id >= 0) {
+			tmp = m->devs[id];
+			m->devs[id] = NULL;
+			pr_info("%s - interface %s unregistered\n", type_names[m->type], dev->name);
+			if (m->dev_count == id + 1)
+				m->dev_count--;
+			mutex_unlock(&m->lock);
+			dev_put(tmp);
+			mutex_lock(&m->lock);
+		}
+		break;
+	case NETDEV_CHANGENAME:
+		if (id >= 0 && !name_matches_type(dev->name, m->type)) {
+			tmp = m->devs[id];
+			m->devs[id] = NULL;
+			pr_info("%s - interface %s unregistered (name changed)\n",
+				type_names[m->type], dev->name);
+			if (m->dev_count == id + 1)
+				m->dev_count--;
+			mutex_unlock(&m->lock);
+			dev_put(tmp);
+			mutex_lock(&m->lock);
+			break;
+		}
+		fallthrough;
+	case NETDEV_REGISTER:
+		if (id < 0 && name_matches_type(dev->name, m->type)) {
+			newid = -1;
+			for (i = 0; i < m->dev_count; i++) {
+				if (!m->devs[i]) {
+					newid = i;
+					break;
+				}
+			}
+			if (newid < 0 && m->dev_count < MAX_IFACES)
+				newid = m->dev_count++;
+			if (newid >= 0) {
+				dev_hold(dev);
+				m->devs[newid] = dev;
+				pr_info("%s - interface %s registered\n", type_names[m->type], dev->name);
+			}
+		}
+		break;
+	}
+	mutex_unlock(&m->lock);
+	return NOTIFY_DONE;
+}
+
+/* find/create manager for base family */
+static struct net_mgr *net_mgr_get(enum net_trig_type type)
+{
+	struct net_mgr *m, *existing = NULL;
+
+	if (type >= NET_TRIG_TYPE_MAX)
+		return NULL;
+
+	/* fast-path: if already exists, bump ref and return */
+	mutex_lock(&managers_lock);
+	m = managers[type];
+	if (m) {
+		atomic_inc(&m->refcnt);
+		mutex_unlock(&managers_lock);
+		return m;
+	}
+	mutex_unlock(&managers_lock);
+
+	/* allocate and init (not yet published) */
+	m = kzalloc(sizeof(*m), GFP_KERNEL);
+	if (!m)
+		return NULL;
+
+	m->type = type;
+	mutex_init(&m->lock);
+	INIT_LIST_HEAD(&m->leds);
+	atomic_set(&m->refcnt, 1);
+	INIT_DELAYED_WORK(&m->work, net_mgr_work);
+
+	m->notifier.notifier_call = net_mgr_notify;
+	m->notifier.priority = 0;
+
+	/* try to register notifier; on failure clean up and return */
+	if (register_netdevice_notifier(&m->notifier)) {
+		kfree(m);
+		return NULL;
+	}
+
+	/* publish manager, but handle rare race where another thread created it */
+	mutex_lock(&managers_lock);
+	existing = managers[type];
+	if (existing) {
+		/* use existing one: increase refcount, drop our resources */
+		atomic_inc(&existing->refcnt);
+		mutex_unlock(&managers_lock);
+
+		unregister_netdevice_notifier(&m->notifier);
+		kfree(m);
+
+		return existing;
+	}
+
+	/* no existing manager -> publish ours */
+	managers[type] = m;
+	mutex_unlock(&managers_lock);
+
+	/* start background work */
+	schedule_delayed_work(&m->work, 0);
+
+	return m;
+}
+
+static void net_mgr_put(struct net_mgr *m)
+{
+	int i;
+	if (!m)
+		return;
+
+	if (atomic_dec_and_test(&m->refcnt)) {
+		mutex_lock(&managers_lock);
+		if (managers[m->type] == m)
+			managers[m->type] = NULL;
+		mutex_unlock(&managers_lock);
+
+		cancel_delayed_work_sync(&m->work);
+		unregister_netdevice_notifier(&m->notifier);
+
+		mutex_lock(&m->lock);
+		for (i = 0; i < m->dev_count; i++)
+			if (m->devs[i])
+				dev_put(m->devs[i]);
+		mutex_unlock(&m->lock);
+
+		kfree(m);
+	}
+}
+
+/* deactivate: detach led from manager */
+static void net_deactivate(struct led_classdev *led_cdev)
+{
+	struct net_led *entry = led_cdev->trigger_data;
+	struct net_mgr *m;
+
+	if (!entry)
+		return;
+
+	m = entry->mgr;
+	if (!m) {
+		/* defensive: shouldn't happen, but avoid crash */
+		led_cdev->trigger_data = NULL;
+		kfree(entry);
+		return;
+	}
+	mutex_lock(&m->lock);
+	list_del(&entry->node);
+	mutex_unlock(&m->lock);
+
+	led_set_off_full(led_cdev, false);
+	led_cdev->trigger_data = NULL;
+
+	pr_info("LED %s - trigger %s%s detached\n",
+		dev_name(led_cdev->dev),
+		type_names[m->type],
+		entry->online_only ? "-online" : "");
+
+	kfree(entry);
+	net_mgr_put(m);
+}
+
+/* activate/deactivate: attach led to manager and remember online_only flag */
+static int net_activate(struct led_classdev *led_cdev)
+{
+	const char *fn = NULL;
+	int parsed;
+	bool online_only = false;
+	struct net_mgr *m;
+	struct net_led *entry;
+	const char *name;
+	const char *sep;
+
+	if (!led_cdev) {
+		pr_err("network: net_activate called with NULL led_cdev\n");
+		return -EINVAL;
+	}
+	if (!led_cdev->dev) {
+		pr_err("network: LED device is NULL, aborting activate\n");
+		return -EINVAL;
+	}
+	name = dev_name(led_cdev->dev);
+	if (!name || !*name) {
+		pr_err("network: LED has no name, aborting activate\n");
+		return -EINVAL;
+	}
+	if (led_cdev->trigger_data) {
+		pr_warn("network: LED %s already has trigger_data set, refusing attach\n",
+			name);
+		return -EBUSY;
+	}
+
+	/* 
+	 * Prefer core-supplied transient params if present (format: "network:params").
+	 * Do NOT consume or free led_cdev->params here - core will free it
+	 * after activate returns if the trigger doesn't take ownership.
+	 */
+	if (led_cdev->params && led_cdev->params[0]) {
+		fn = led_cdev->params;
+	} else {
+		/* fallback: parse function from LED name "<color>:<function>" */
+		sep = strrchr(name, ':');
+		if (sep && sep[1] != '\0') {
+			fn = sep + 1;
+		} else {
+			/* fallback: try the whole name */
+			fn = name;
+		}
+	}
+
+	/* If function not recognised, return -EINVAL to signal invalid configuration to userspace */
+	parsed = parse_function_string(fn, &online_only);
+	if (parsed < 0) {
+		pr_info("network: unknown function '%s' for LED %s\n", fn ?: "<NULL>", name);
+		return -EINVAL;
+	}
+
+	m = net_mgr_get(parsed);
+	if (!m)
+		return -ENOMEM;
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry) {
+		net_mgr_put(m);
+		return -ENOMEM;
+	}
+
+	entry->led_cdev = led_cdev;
+	entry->mgr = m;
+	entry->last_rx_packets = entry->last_tx_packets = 0;
+	entry->last_rx_bytes = entry->last_tx_bytes = 0;
+	entry->online_only = online_only;
+
+	/* attach under manager lock and initialize history to current aggregates */
+	mutex_lock(&m->lock);
+	list_add_tail(&entry->node, &m->leds);
+
+	/* initialize history so future non-online_only reads won't see a spurious delta */
+	entry->last_rx_packets = m->agg_rx_packets;
+	entry->last_tx_packets = m->agg_tx_packets;
+	entry->last_rx_bytes   = m->agg_rx_bytes;
+	entry->last_tx_bytes   = m->agg_tx_bytes;
+	mutex_unlock(&m->lock);
+
+	led_cdev->trigger_data = entry;
+	pr_info("LED %s - trigger %s%s attached\n",
+		name,
+		type_names[m->type],
+		entry->online_only ? "-online" : "");
+	return 0;
+}
+
+static struct led_trigger network_trigger = {
+	.name = "network",
+	.activate = net_activate,
+	.deactivate = net_deactivate,
+};
+
+module_led_trigger(network_trigger);
+
+MODULE_AUTHOR("Mieczyslaw Nalewaj <namiltd@yahoo.com>");
+MODULE_DESCRIPTION("LED trigger for network interfaces - aggregated per-family (lan/wan/wlan) with optional per-LED '-online' behaviour");
+MODULE_LICENSE("GPL v2");
--- a/drivers/leds/trigger/Makefile
+++ b/drivers/leds/trigger/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= led
 obj-$(CONFIG_LEDS_TRIGGER_PATTERN)	+= ledtrig-pattern.o
 obj-$(CONFIG_LEDS_TRIGGER_TTY)		+= ledtrig-tty.o
 obj-$(CONFIG_LEDS_TRIGGER_INPUT_EVENTS)	+= ledtrig-input-events.o
+obj-$(CONFIG_LEDS_TRIGGER_NETWORK)	+= ledtrig-network.o
